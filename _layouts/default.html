<!DOCTYPE html>
{% assign sortedtags = "" | split: "," %}
{% for page in site.pages %}{% if page.path contains 'data/tags/' %}{% assign tag_name_size = page.name | size | minus: 3 %}{% assign tag = page.name | slice: 0, tag_name_size %}{% assign sortedtags = sortedtags | push: tag %}{% endif %}{% endfor %}
{% assign sortedtags = sortedtags | sort %}

{% assign docs = "" | split:"," %}
{% for doc_ in site.data.documents %}{% assign docs = docs | push: doc_[1] %}{% endfor %}
{% assign docs = (docs | sort: 'date') | reverse %}
{% assign tag_name_size = page.name | size | minus: 3 %}{% assign tag = page.name | slice: 0, tag_name_size %}

{% assign num_docs = site.data.documents | size %}
{% assign recent_docs = site.recent_docs %}
{% if num_docs < recent_docs %}{% assign recent_docs = num_docs %}{% endif %}
{% if page.recent_docs == true %}{% assign docs = docs | slice: 0, recent_docs %}{% endif %}

{% if page.path contains "data/tags/" %}
	{% assign docs_by_tag = "" | split:"," %}
	{% for doc in docs %}{% if doc.tags contains tag %}{% assign docs_by_tag = docs_by_tag | push: doc %}{% endif %}{% endfor %}
	{% assign docs = docs_by_tag %}
{% endif %}
			    
{% assign tag_xml = tag %}{% if tag == "all" %}{% assign tag_xml = "recent" %}{% endif %}
{% if page.import_docs == true %}{% assign docs = "" | split:"," %}{% endif %}

<html lang="en-US">
	<head>
		<title>zrxiv for {{ site.github.owner_name }}</title>
		<meta charset="UTF-8">
    		<meta http-equiv="X-UA-Compatible" content="IE=edge">
    		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta property="og:site_name" content="zrxiv" />
		<meta property="profile:uername" content="{{ site.github.owner_name }}" />
		<meta property="og:locale" content="en_US" />
		<meta property="og:title" content="zrxiv for {{ site.github.owner_name }}" />
		<meta property="og:url" content="{{ site.github.url }}" />
		<meta property="og:image" content="{{ site.github.url }}/logo.png" />
		<link rel="icon" href="{{ site.github.url }}/logo.png" />
		<link rel="canonical" href="{{ site.github.url }}" />
		<link rel="stylesheet" href="{{ site.github.url }}/style.css">
		<link href="{{ site.github.url }}/{{ tag_xml }}.xml" type="application/rss+xml" rel="alternate" title="Latest 50 {{ tag_xml }} papers (atom)" />
		<style>
			/*@media screen and (min-width: 1000px){ .container-lg {width: 1000px !important; padding: 0px !important} }*/
			html { overflow-y: scroll; }
			
			h1 {overflow-y:auto}
			input[type=text] {margin-left: auto}
			input[type=checkbox] {align-self: center}
			ul {margin: 0px; list-style:none; padding:0 !important; margin-top: 1em !important}
			li {padding:6px 13px;border:1px solid #dfe2e5; margin:0px !important}
			li:last-child {border-bottom:1px solid #dfe2e5}
			.doc-even {background-color:#f6f8fa; border-top:0px; border-bottom:0px}
			.doc-deleted {background-color: orangered !important }
			.doc>div {display:flex}
			#zrxiv_doc_header>div {display:flex}
			#zrxiv_doc_header {background-color: #dfe2e5}
			
			.tag_highlight {background-color: lightyellow}
			.tag_special {color:red; margin-right: 2pt}
			.tag {color:red}
			.tag::before {content: "#"}
			.tag:not(:first-child) {margin-left: 5px;}
			.tags {display:flex; flex-grow:1; flex-wrap: wrap; justify-content:flex-end; }
			.tags-header {display:flex; flex-wrap: wrap; }
			
			.authors {display:flex; flex-grow:1; flex-wrap:wrap; }
			.author {color:lightgray; font-size:small}
			a.author:not(:last-child)::after {content: ","; margin-right: 2pt; }
			
			.date>a {color:lightgray; font-size:small; white-space:nowrap; margin-left: 3px; }
			.date {display: flex; align-items:flex-end; }
						
			.title {flex-grow:1; }
			.source { color:lightgray }
			
			#bibtex_copy_area, #zrxiv_deleted_docs {height: 0px; width: 0px; overflow: hidden; position: absolute; left: -10000px; }
			.separator_before::before { content: " | " }
			
			.subtitle-unchecked { font-size:small; color:lightgray; margin-left: 2pt}
			.subtitles {float:right; font-size:small; color:lightgray; }
			
			#import_area { width: 100%; height: 100pt; margin-top: 1em }
			#import_button {margin-right: 10pt; margin-left: auto; margin-right: auto; display : block}
			.visibility_hidden {visibility : hidden}
		</style>
	</head>
	<body onhashchange="navigate()" onload="navigate()">
		<textarea id="bibtex_copy_area"></textarea>
		<textarea id="zrxiv_deleted_docs" onchange="update_deleted_docs(this.value)"></textarea>
		<div class="container-lg px-3 my-5 markdown-body">
			<h1><a href="{{ site.github.url }}" title="Page [{{ tag }}] updated at {{ site.time | date: "%Y, %B %-d, %H:%M GMT" }}">‚Ñ§rxiv</a> for  {{ site.github.owner_name }}{% if page.import_docs != true %} <span class="subtitles"><a href="{{ site.github.url }}/{{ tag }}.bib" class="subtitle-unchecked" download>{{tag}}.bib</a><a href="{{ site.github.url }}/{{ tag }}.json" class="subtitle-unchecked">.json</a><a href="{{ site.github.url }}/{{ tag }}.txt" class="subtitle-unchecked">.txt</a><a href="{{ site.github.url }}/{{ tag_xml }}.xml" class="subtitle-unchecked">.rss</a></span>{% endif %}</h1>
			<div class="tags-header" data-selected=""><a href="{{ site.github.url }}" class="tag_special {% if tag == "recent" %}tag_highlight{% endif %}">üè†recent</a><a href="{{ site.github.url }}/all" class="tag_special {% if tag == "all" %}tag_highlight{% endif %}">üìöall</a><a href="{{ site.github.url }}/import" class="tag_special {% if tag == "import" %}tag_highlight{% endif %}">üì•import</a>{% for sortedtag in sortedtags %}<a href="{{ site.github.url }}/{{ sortedtag }}" class="tag {% if sortedtag == tag %}tag_highlight{% endif %}">{{ sortedtag }}</a>{% endfor %}<input id="filter_area" type="text" {% if page.import_docs == true %}class="visibility_hidden"{% endif %}></input><button id="filter" onclick="filter_click()" {% if page.import_docs == true %}class="visibility_hidden"{% endif %}>Filter</button></div>
			{% if page.import_docs == true %}
			<div>
				<textarea id="import_area" placeholder="Paste here (or upload a file) BibTeX, arXiv id list or arXiv/openreview url list"></textarea>
				<input id="import" type="file"></input>
				<button id="import_button" onclick="import_click()">Import</button>
			</div>
			{% endif %}
			<ul {% if page.import_docs == true %}hidden{% endif %}><li id="zrxiv_doc_header">
				<div><div class="title"><input type="checkbox" onchange="reset_selection()"></input><span class="title"><span id="num_docs_filtered">{{ docs | size }}</span> documents <a href="{{ site.github.url }}/{{ tag }}.bib" id="bibtex_filtered" download="zrxiv_{{ site.github.owner_name }}_{{ tag }}_filtered.bib">filtered</a>, <span id="num_docs_selected">0</span> documents <a href="data:text/plain;base64," id="bibtex_selected" download="zrxiv_{{ site.github.owner_name }}_{{ tag }}_selected.bib">selected</a></span></div></div>
			    </li>
				{% for doc in docs %}
				{% assign lastnames = "" | split: "," %}{% for author in doc.authors %}{% assign lastname = (author | split: " ") | last %}{% assign lastnames = lastnames | push: lastname %}{% endfor %}
				<li class="doc {% cycle '', 'doc-even' %}" data-authors="{{ lastnames | join: ' ' | downcase }}" data-tags="{{ doc.tags | join: ' ' | downcase }} {{ doc.source | downcase }} {{ doc.date | date: "%Y-%m-%d" }}" data-title="{{ doc.title | strip | strip_html | downcase | escape }}" data-id="{{ doc.id }}">
					<div>
						<div class="title"><input type="checkbox" onchange="update_docs_header(false, true)"></input><a class="title" href="{{ doc.url }}" title="{{ doc.abstract | strip | strip_html | escape }}">{{ doc.title | strip | strip_html | escape }}</a></div>
						<div class="tags">{% if doc.source and doc.source != "" %}<a class="source" href="{{ site.github.url }}/all#filter=#{{ doc.source | downcase }}">#{{ doc.source }}</a>{% endif %}{% for tag in doc.tags %}<a href="{{ site.github.url }}/{{ tag }}" class="tag">{{ tag }}</a>{% endfor %}</div>
					</div>
					<div>
						<div class="authors">{% for author in doc.authors %}{% assign lastname = (author | split: " ") | last %}<a href="{{ site.github.url }}/all#filter=@{{ lastname | downcase }}" class="author" title="{{ author }}">{{ lastname }}</a>{% endfor %}</div>
						<div class="date">{% if doc.bibtex and doc.bibtex != "" %}<a class="bibtex_copy" href="#" onclick="bibtex_copy(this); return false" title="{{ doc.bibtex | escape }}">copy bibtex</a>{% endif %}<a class="{% if doc.bibtex and doc.bibtex != "" %}separator_before{%endif%}" href="{{ site.github.url }}/all#filter=#{{ doc.date | date: "%Y-%m-%d" }}" title="added at {{ doc.date | date: "%Y, %B %-d, %H:%M GMT" }}">#{{ doc.date | date: "%Y-%m-%d" }}</a></div>
					</div>
				</li>
				{% endfor %}
			</ul>
		</div>
		<template id="doc_tmpl"><li class="doc filtered" data-authors="" data-tags="" data-title="">
			<div>
				<div class="title"><input type="checkbox" onchange="update_docs_header(false, true)"></input><a class="title" href="" title=""></a></div>
				<div class="tags"><a class="source" href=""></a></div>
			</div>
			<div>
				<div class="authors"></div>
				<div class="date"><a class="bibtex_copy" href="" onclick="bibtex_copy(this); return false" title="">copy bibtex</a></div>
			</div>
		</li></template>
		<script type="text/javascript">
			function parse_bibtex(text)
			{
				const parse_bibtex_line = function(text)
				{
					let m = text.match(/^\s*(\S+?)\s*=\s*/);
					if (!m) 
						throw new Error('Unrecogonised line format');
					const name = m[1];
					const search = text.slice(m[0].length);
					const re = /[\n\r,{}]/g;
					let length = m[0].length;
					let braceCount = 0;
					do
					{
						m = re.exec(search);
						if (m[0] === '{')
							braceCount++;
						else if (m[0] === '}')
						{
							if (braceCount ===  0)
								throw new Error('Unexpected closing brace: "}"');
							braceCount--;
						}
					}
					while (braceCount > 0);
					const value = search.slice(0, re.lastIndex);
					length += re.lastIndex;

					while(true)
					{
						m = re.exec(search);
						if(m[0] != '{' && m[0] != '}')
							length += m[0].length;
						else
							break;
					}

					return [name, value, length];
				};

				let res = [];
				while(text.length > 0)
				{
					const m = text.match(/^\s*@([^{]+){\s*([^,\n]+)[,\n]/);
					if (!m) 
						throw new Error('Unrecogonised header format');
					text = text.slice(m[0].length).trim();
					let bib = {};
					while (text[0] !== '}')
					{
						let [field, value, length] = parse_bibtex_line(text);
						while(value.startsWith('{'))
							value = value.slice(1);
						while(value.endsWith('}'))
							value = value.slice(0, -1);
						bib[field.toLowerCase()] = value;
						text = text.slice(length).trim();
					}
					if(text[0] == '}')
						text = text.slice(1).trim();
					
					bib.bibtex_record_type = m[1].trim().toLowerCase();
					bib.bibtex_citation_key = m[2].trim().toLowerCase();
					bib.authors = (bib.author.includes(' and ') ? bib.author.split(' and ') : bib.author.split(', ')).map(author => 
					{
						if(author.includes(','))
						{
							let splitted = author.split(',');
							author = splitted.slice(1).join(' ') + ' ' + splitted[0];
						}
						return author;
					});
					delete bib.author;
					res.push(bib);
				}
				return res;
			}
			
			function format_bibtex(bib)
			{
				bib = Object.assign({}, bib);
				bib.author = bib.authors.join(' and ');
				const exclude_keys = ['bibtex_record_key', 'bibtex_citation_key', 'authors'];
        			return `@${bib.bibtex_record_type}{${bib.bibtex_citation_key},\n` + Object.keys(bib).filter(k => !exclude_keys.includes(k)).map(k => `    ${k} = {${bib[k]}}`).join(',\n') + '\n}';
			}
			
			async function import_doc_by_url(url)
			{
				if(url.includes('arxiv.org'))
				{
					const entry = document.createRange().createContextualFragment(await (await fetch(url.replace('arxiv.org/abs/', 'export.arxiv.org/api/query?id_list='))).text()).querySelector('entry');
					const id = entry.querySelector('id').innerText.split('abs/')[1].split('v')[0];
					return {
						title : entry.querySelector('title').innerText,
						authors : Array.from(entry.querySelectorAll('author name')).map(elem => elem.innerText),
						url : url,
						abstact : entry.querySelector('summary').innerText,
						bibtex : null,
						id : 'arxiv.' + id,
						bibtex_citation_key : 'arxiv.' + id,
						bibtex_record_type : 'misc'
					};
				}
				
				return null;
			}
			
			async function import_click()
			{
				const parse_and_show_docs = async function(text)
				{
					let bibs = [];
					try
					{
						bibs = parse_bibtex(text);
					}
					catch
					{
						const urls = text.match(/[a-zA-Z0-9\/\:\.\?=]+/g).map(s => /^\d{4}\.\d+$/.test(s) ? `https://arxiv.org/abs/${s}` : s.replace('http://', 'https://'));
						bibs = await Promise.all(urls.map(import_doc_by_url));
					}
					const ul = document.getElementsByTagName('ul')[0];
					const doc_tmpl = document.getElementById('doc_tmpl').content;
					for(let i = 0; i < bibs.length; i++)
					{
						const bib = bibs[i];
						let li = document.importNode(doc_tmpl, true).firstChild;
						li.querySelector('a.bibtex_copy').title = format_bibtex(bib);
						if(i % 2 == 1)
							li.classList.add('doc-even');
						let a = li.querySelector('a.title');
						a.innerText = bib.title;
						a.href = bib.url;
						let div = li.querySelector('.authors');
						const site_root = document.querySelector("meta[property='og:url']").getAttribute('content');
						let lastnames = [];
						for(let j = 0; j < bib.authors.length; j++)
						{
							const [lastname, fullname] = [bib.authors[j].split(' ').pop(), bib.authors[j]]);
							lastnames.push(lastname.toLowerCase());
							a = document.createElement('a');
							a.className = 'author';
							a.innerText = lastname;
							a.title = fullname;
							a.href = '#filter=@' + lastname.toLowerCase();
							div.appendChild(a);
						}
						li.dataset.authors = lastnames.join(' ');
						li.dataset.title = bib.title.toLowerCase();
						ul.appendChild(li);
					};
					update_docs_header(true, true);
					document.querySelectorAll('#filter_area, #filter').forEach(el => el.classList.remove('visibility_hidden'));
					reset_selection(true);
					ul.removeAttribute('hidden');
				};
				
				const ul = document.getElementsByTagName('ul')[0];
				while(ul.childNodes.length > 1) ul.lastChild.remove();
				
				const files = document.getElementById('import').files;
				const pasted = document.getElementById('import_area').value;
				
				if(pasted.length > 0)
					parse_and_show_docs(pasted);
				
				for(let i = 0; i < files.length; i++)
				{
					const file_reader = new FileReader(); 
					file_reader.onload = e => parse_and_show_docs(e.target.result);
					file_reader.readAsText(files[i]);
				}
			}
			
			function read_deleted_docs()
			{
				let docs = document.cookie.split('deleted_docs=');
				docs = docs.length >= 2 ? docs[1].split(';')[0].trim() : '';
				docs = docs.length > 0 ? docs.split(',') : [];
				return docs.filter(doc => doc).map(doc => doc.trim());
			}
			
			function mark_deleted_docs()
			{
				const docs = read_deleted_docs();
				if(docs.length > 0)
					document.querySelectorAll(docs.map(doc => `li[data-id="${doc}"]`).join(',')).forEach(li => {
						li.title = 'Document is being deleted';
						li.classList.add('doc-deleted');
						const checkbox = li.querySelector('input[type=checkbox]');
						checkbox.checked = false;
						checkbox.disabled = true;
					});
			}
			
			function update_deleted_docs(docs)
			{
				const expires_in_minutes = 15;
				var date = new Date();
				date.setTime(date.getTime() + expires_in_minutes * 60 * 1000);
				const deleted_docs = Array.from(new Set(read_deleted_docs().concat(docs.trim().split(' '))));
				document.cookie = `deleted_docs=${deleted_docs.join(',')}; expires=${date.toGMTString()}`;
				mark_deleted_docs();
			}
			
			function update_docs_header(filtered, selected)
			{
				const base64_encode_utf8 = str => btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {return String.fromCharCode(parseInt(p1, 16)) }));
			
				if(filtered === true)
				{
					const docs = Array.from(document.querySelectorAll('.doc.filtered'));
					document.getElementById('num_docs_filtered').innerText = docs.length.toString();
					document.getElementById('bibtex_filtered').href = "data:text/plain;base64," + base64_encode_utf8(docs.map(li => li.querySelector('a.bibtex_copy')).filter(a => a != null).map(a => a.title).join('\n\n'));
				}
				
				if(selected === 0 || selected === true)
				{
					const docs = selected === true ? Array.from(document.querySelectorAll('.doc.filtered input[type=checkbox]:checked:not([disabled])')).map(input => input.parentNode.parentNode.parentNode) : [];
					document.getElementById('num_docs_selected').innerText = docs.length.toString();
					document.getElementById('bibtex_selected').href = "data:text/plain;base64," + base64_encode_utf8(docs.map(li => li.querySelector('a.bibtex_copy')).filter(a => a != null).map(a => a.title).join('\n\n'));
					document.getElementById('zrxiv_doc_header').dataset.selected = docs.map(li => li.dataset.id).filter(id => id).join(' ');
				}
			}
			
			function bibtex_copy(a)
			{
				const textarea = document.getElementById('bibtex_copy_area');
				textarea.value = a.title;
				textarea.select();
				document.execCommand('copy');
			}
			
			function filter_keyup(event)
			{
				if (event.keyCode == 13)
					document.getElementById('filter').click();
			}
			
			function filter_click()
			{
				window.location = (window.location.pathname.slice(-1) == '/' ? (window.location.pathname + 'all') : '') + '#filter=' + document.getElementById('filter_area').value.split(' ').join('+');
			}
			
			function reset_selection(select_all)
			{
				if(select_all !== true && document.querySelectorAll('li.filtered input[type=checkbox]:checked').length > 0)
				{
					document.querySelectorAll('input[type=checkbox]').forEach(checkbox => {checkbox.checked = false;});
					update_docs_header(false, 0);
				}
				else
				{
					const checkboxes = document.querySelectorAll('li.filtered input[type=checkbox]:not([disabled]), #zrxiv_doc_header input[type=checkbox]');
					checkboxes.forEach(checkbox => {checkbox.checked = true;});
					update_docs_header(false, true);
				}
			}
			
			function navigate()
			{
				const hash = window.location.hash != '' ? decodeURIComponent(window.location.hash.substr('#filter='.length)).split('+').join(' ') : '';
				const routes = {'#' : 'data-tags~', '@' : 'data-authors~', '': 'data-title*'};
				const sorted = Object.keys(routes).sort((lhs, rhs) => rhs.length - lhs.length);
				const selector = hash != '' ? hash.split(' ').map(w => [w, sorted.find(r => w.startsWith(r))]).map(([w, r]) => `[${routes[r]}="${w.substr(r.length).toLowerCase()}"]`).join('') : '';
				document.getElementById('filter_area').value = hash;
				document.getElementById('filter_area').onkeyup = filter_keyup;
				document.querySelectorAll('.doc').forEach(d => d.classList.remove('filtered'));
				document.querySelectorAll('.doc' + selector).forEach(d => d.classList.add('filtered'));
				document.querySelectorAll('.doc:not(.filtered)').forEach(d => {d.hidden = true;});
				document.querySelectorAll('.doc.filtered').forEach((li, row_index, hidden) =>
				{
					if(row_index % 2 == 1)
						li.classList.add('doc-even');
					else
						li.classList.remove('doc-even');
					li.hidden = false;
				});
				update_docs_header(selector != '', selector != '');
				mark_deleted_docs();
			}
		</script>
	</body>
</html>
