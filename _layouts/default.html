<!DOCTYPE html>
{% assign sortedtags = "" | split: "," %}
{% for page in site.pages %}{% if page.path contains 'data/tags/' %}{% assign tag_name_size = page.name | size | minus: 3 %}{% assign tag = page.name | slice: 0, tag_name_size %}{% assign sortedtags = sortedtags | push: tag %}{% endif %}{% endfor %}
{% assign sortedtags = sortedtags | sort %}

{% assign docs = "" | split:"," %}
{% for doc_ in site.data.documents %}{% assign docs = docs | push: doc_[1] %}{% endfor %}
{% assign docs = (docs | sort: 'date') | reverse %}
{% assign tag_name_size = page.name | size | minus: 3 %}{% assign tag = page.name | slice: 0, tag_name_size %}

{% assign num_docs = site.data.documents | size %}
{% assign recent_docs = site.recent_docs %}
{% if num_docs < recent_docs %}{% assign recent_docs = num_docs %}{% endif %}
{% if page.recent_docs == true %}{% assign docs = docs | slice: 0, recent_docs %}{% endif %}

{% if page.path contains "data/tags/" %}
	{% assign docs_by_tag = "" | split:"," %}
	{% for doc in docs %}{% if doc.tags contains tag %}{% assign docs_by_tag = docs_by_tag | push: doc %}{% endif %}{% endfor %}
	{% assign docs = docs_by_tag %}
{% endif %}
			    
{% assign tag_xml = tag %}{% if tag == "all" %}{% assign tag_xml = "recent" %}{% endif %}
{% if page.import_docs == true %}{% assign docs = "" | split:"," %}{% endif %}

<html lang="en-US">
	<head>
		<title>zrxiv for {{ site.github.owner_name }}</title>
		<meta charset="UTF-8">
    		<meta http-equiv="X-UA-Compatible" content="IE=edge">
    		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta property="og:site_name" content="zrxiv" />
		<meta property="profile:uername" content="{{ site.github.owner_name }}" />
		<meta property="og:locale" content="en_US" />
		<meta property="og:title" content="zrxiv for {{ site.github.owner_name }}" />
		<meta property="og:url" content="{{ site.github.url }}" />
		<meta property="og:image" content="{{ site.github.url }}/logo.png" />
		<link rel="icon" href="{{ site.github.url }}/logo.png" />
		<link rel="canonical" href="{{ site.github.url }}" />
		<link rel="stylesheet" href="{{ site.github.url }}/style.css">
		<link href="{{ site.github.url }}/{{ tag_xml }}.xml" type="application/rss+xml" rel="alternate" title="Latest 50 {{ tag_xml }} papers (atom)" />
		<style>
			h1 {overflow-y:auto}
			input[type=text] {margin-left: auto}
			input[type=checkbox] {align-self: center}
			ul {margin: 0px; list-style:none; padding:0 !important; margin-top: 1em !important}
			li {padding:6px 13px;border:1px solid #dfe2e5; margin:0px !important}
			li:last-child {border-bottom:1px solid #dfe2e5}
			.doc-even {background-color:#f6f8fa; border-top:0px; border-bottom:0px}
			.doc>div {display:flex}
			.doc-header>div {display:flex}
			.docs_hidden {display: none}
			
			.tag_highlight {background-color: lightyellow}
			.tag_special {color:red; margin-right: 2pt}
			.tag {color:red}
			.tag::before {content: "#"}
			.tag:not(:first-child) {margin-left: 5px;}
			.tags {display:flex; flex-grow:1; flex-wrap: wrap; justify-content:flex-end; }
			.tags-header {display:flex; flex-wrap: wrap; }
			
			.authors {display:flex; flex-grow:1; flex-wrap:wrap; }
			.author {color:lightgray; font-size:small}
			a.author:not(:last-child)::after {content: ","; margin-right: 2pt; }
			
			.date>a {color:lightgray; font-size:small; white-space:nowrap; margin-left: 3px; }
			.date {display: flex; align-items:flex-end; }
						
			.title {flex-grow:1; }
			.source { color:lightgray }
			
			#bibtex_copy_area {height: 0px; width: 0px; overflow: hidden; position: absolute; left: -10000px; }
			.separator_before::before { content: " | " }
			
			.import_button {margin-right: 10pt; margin-left: auto; margin-right: auto; display : block}
			
			.subtitle-unchecked { font-size:small; color:lightgray; margin-left: 2pt}
			.subtitles {float:right; font-size:small; color:lightgray; }
		</style>
	</head>
	<body onhashchange="navigate()" onload="navigate()">
		<textarea id="bibtex_copy_area"></textarea>
		<div class="container-lg px-3 my-5 markdown-body">
			<h1><a href="{{ site.github.url }}" title="Page [{{ tag }}] updated at {{ site.time | date: "%Y, %B %-d, %H:%M GMT" }}">‚Ñ§rxiv</a> for  {{ site.github.owner_name }}{% if page.import_docs != true %} <span class="subtitles"><a href="{{ site.github.url }}/{{ tag }}.bib" class="subtitle-unchecked" download>{{tag}}.bib</a><a href="{{ site.github.url }}/{{ tag }}.json" class="subtitle-unchecked">.json</a><a href="{{ site.github.url }}/{{ tag }}.txt" class="subtitle-unchecked">.txt</a><a href="{{ site.github.url }}/{{ tag }}.xml" class="subtitle-unchecked">.rss</a></span>{% endif %}</h1>
			<div class="tags-header"><a href="{{ site.github.url }}" class="tag_special {% if tag == "recent" %}tag_highlight{% endif %}">üè†recent</a><a href="{{ site.github.url }}/all" class="tag_special {% if tag == "all" %}tag_highlight{% endif %}">üìöall</a><a href="{{ site.github.url }}/import" class="tag_special {% if tag == "import" %}tag_highlight{% endif %}">üì•import</a>{% for sortedtag in sortedtags %}<a href="{{ site.github.url }}/{{ sortedtag }}" class="tag {% if sortedtag == tag %}tag_highlight{% endif %}">{{ sortedtag }}</a>{% endfor %}<input id="filter_area" type="text"></input><button id="filter" onclick="filter_click()">Filter</button></div>
			
			{% if page.import_docs == true %}
			<div>
				<button class="import_button"><label for="import">Import BibTeX</label></button>
				<input type="file" id="import" name="import" hidden onchange="import_click()"></import>
			</div>
			{% endif %}

			<ul class="{% if docs.size == 0 %}docs_hidden{% endif %}"><li class="doc-header">
					<div>
						<div class="title"><input type="checkbox" onchange="reset_selection()"></input><span class="title"><span id="num_docs_filtered">{{ docs | size }}</span> documents filtered, <span id="num_docs_selected">0</span> documents selected</span></div>
						<div class="tags"><a class="bibtex_copy" id="bibtex_download" href="" onclick="bibtex_copy(this); return false">copy bibtex</a></div>
					</div>
				</li>
				{% for doc in docs %}
				{% assign lastnames = "" | split: "," %}{% for author in doc.authors %}{% assign lastname = (author | split: " ") | last %}{% assign lastnames = lastnames | push: lastname %}{% endfor %}
				<li class="doc {% cycle '', 'doc-even' %}" data-authors="{{ lastnames | join: ' ' | downcase }}" data-tags="{{ doc.tags | join: ' ' | downcase }} {{ doc.source | downcase }} {{ doc.date | date: "%Y-%m-%d" }}" data-title="{{ doc.title | strip | strip_html | downcase | escape }}">
					<div>
						<div class="title"><input type="checkbox" onchange="update_docs_counter(false, true)"></input><a class="title" href="{{ doc.url }}" title="{{ doc.abstract | strip | strip_html | escape }}">{{ doc.title | strip | strip_html | escape }}</a></div>
						<div class="tags">{% if doc.source and doc.source != "" %}<a class="source" href="{{ site.github.url }}/all#filter=#{{ doc.source | downcase }}">#{{ doc.source }}</a>{% endif %}{% for tag in doc.tags %}<a href="{{ site.github.url }}/{{ tag }}" class="tag">{{ tag }}</a>{% endfor %}</div>
					</div>
					<div>
						<div class="authors">{% for author in doc.authors %}{% assign lastname = (author | split: " ") | last %}<a href="{{ site.github.url }}/all#filter=@{{ lastname | downcase }}" class="author" title="{{ author }}">{{ lastname }}</a>{% endfor %}</div>
						<div class="date">{% if doc.bibtex and doc.bibtex != "" %}<a class="bibtex_copy" href="#" onclick="bibtex_copy(this); return false" title="{{ doc.bibtex | escape }}">copy bibtex</a>{% endif %}<a class="{% if doc.bibtex and doc.bibtex != "" %}separator_before{%endif%}" href="{{ site.github.url }}/all#filter=#{{ doc.date | date: "%Y-%m-%d" }}" title="added at {{ doc.date | date: "%Y, %B %-d, %H:%M GMT" }}">#{{ doc.date | date: "%Y-%m-%d" }}</a></div>
					</div>
				</li>
				{% endfor %}
			</ul>
		</div>
		<template id="doc_tmpl"><li class="doc filtered" data-authors="" data-tags="" data-title="">
			<div>
				<div class="title"><input type="checkbox"></input><a class="title" href="" title=""></a></div>
				<div class="tags"><a class="source" href=""></a></div>
			</div>
			<div>
				<div class="authors"></div>
				<div class="date"><a class="bibtex_copy" href="" onclick="bibtex_copy(this); return false" title="">copy bibtex</a></div>
			</div>
		</li></template>
		<script type="text/javascript">
			function base64_encode_utf8(str)
			{
			    return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {return String.fromCharCode(parseInt(p1, 16)) }));
			}
			
			function parse_bibtex(text)
			{
				const parse_bibtex_line = function(text)
				{
					let m = text.match(/^\s*(\S+?)\s*=\s*/);
					if (!m) 
						throw new Error('Unrecogonised line format');
					const name = m[1];
					const search = text.slice(m[0].length);
					const re = /[\n\r,{}]/g;
					let length = m[0].length;
					let braceCount = 0;
					do
					{
						m = re.exec(search);
						if (m[0] === '{')
							braceCount++;
						else if (m[0] === '}')
						{
							if (braceCount ===  0)
								throw new Error('Unexpected closing brace: "}"');
							braceCount--;
						}
					}
					while (braceCount > 0);
					const value = search.slice(0, re.lastIndex);
					length += re.lastIndex;

					while(true)
					{
						m = re.exec(search);
						if(m[0] != '{' && m[0] != '}')
							length += m[0].length;
						else
							break;
					}

					return [name, value, length];
				};

				let res = [];
				while(text.length > 0)
				{
					const m = text.match(/^\s*@([^{]+){\s*([^,\n]+)[,\n]/);
					if (!m) 
						throw new Error('Unrecogonised header format');
					text = text.slice(m[0].length).trim();
					let bib = {};
					while (text[0] !== '}')
					{
						let [field, value, length] = parse_bibtex_line(text);
						while(value.startsWith('{'))
							value = value.slice(1);
						while(value.endsWith('}'))
							value = value.slice(0, -1);
						bib[field.toLowerCase()] = value;
						text = text.slice(length).trim();
					}
					if(text[0] == '}')
						text = text.slice(1).trim();
					
					res.push([m[1].trim().toLowerCase(), m[2].trim().toLowerCase(), bib]);
				}
				return res;
			}
			
			function format_bibtex(bibtex)
			{
				let [record_type, citation_key, bib] = bibtex;
        			return `@${record_type}{${citation_key},\n` + Object.keys(bib).map(k => `    ${k} = {${bib[k]}}`).join(',\n') + '\n}';
			}
			
			function import_click()
			{
				const files = document.getElementById('import').files;
				if(files.length > 0)
				{
					const fileReader = new FileReader(); 
					fileReader.onload = function (e)
					{
						const bibs = parse_bibtex(e.target.result);
						const ul = document.getElementsByTagName('ul')[0];
						while(ul.childNodes.length > 1) ul.lastChild.remove();
						const doc_tmpl = document.getElementById('doc_tmpl').content;
						for(let i = 0; i < bibs.length; i++)
						{
							const bib = bibs[i];
							let li = document.importNode(doc_tmpl, true).firstChild;
							li.querySelector('a.bibtex_copy').title = format_bibtex(bib);
							if(i % 2 == 1)
								li.classList.add('doc-even');
							let a = li.querySelector('a.title');
							const title = bib[2]['title'];
							a.innerText = title;
							a.href = bib[2]['url'];
							let div = li.querySelector('.authors');
							let authors = (bib[2]['author'].includes(' and ') ? bib[2]['author'].split(' and ') : bib[2]['author'].split(', ')).map(author => 
							{
								if(author.includes(','))
								{
									let splitted = author.split(',');
									return [splitted[0], splitted.slice(1).join(' ') + ' ' + splitted[0]];
								}
								else
								{
									let splitted = author.split(' ');
									return [splitted.pop(), author];
								}
							});
							const site_root = document.querySelector("meta[property='og:url']").getAttribute('content');
							let lastnames = [];
							for(let j = 0; j < authors.length; j++)
							{
								a = document.createElement('a');
								a.className = 'author';
								a.innerText = authors[j][0];
								a.title = authors[j][1];
								const lastname = authors[j][0].toLowerCase();
								a.href = '#filter=@' + lastname;
								div.appendChild(a);
								lastnames.push(lastname)
							}
							li.dataset.authors = lastnames.join(' ');
							li.dataset.title = title.toLowerCase();
							ul.appendChild(li);
						};
						document.querySelectorAll('.docs_hidden').forEach(el => el.classList.remove('docs_hidden'));
						update_tab_bibtex_links('imported');
						update_docs_counter(true, true);
					};
					fileReader.readAsText(files[0]);
				}
			}

			function update_docs_counter(filtered, selected)
			{
				if(filtered === true)
					document.getElementById('num_docs_filtered').innerText = document.querySelectorAll('.doc.filtered').length.toString();
				if(selected === true || (selected !== false))
					document.getElementById('num_docs_selected').innerText = (selected === true ? document.querySelectorAll('.doc.filtered input[type=checkbox]:checked').length : selected).toString();
			}
			
			function reset_doc(li, row_index, hidden)
			{
				if(row_index % 2 == 1)
					li.classList.add('doc-even');
				else
					li.classList.remove('doc-even');
				li.hidden = false;
			}
			
			function bibtex_copy(a)
			{
				const textarea = document.getElementById('bibtex_copy_area');
				textarea.value = a.title;
				textarea.select();
				document.execCommand('copy');
			}
			
			function filter_keyup(event)
			{
				if (event.keyCode == 13)
					document.getElementById('filter').click();
			}
			
			function filter_click()
			{
				window.location = (window.location.pathname.slice(-1) == '/' ? (window.location.pathname + 'all') : '') + '#filter=' + document.getElementById('filter_area').value.split(' ').join('+');
			}
			
			function update_tab_bibtex_links(tab_name)
			{
				const filtered_docs = document.querySelectorAll('.doc:not([hidden])');
				const filtered_docs_bibtex = Array.from(filtered_docs).map(doc => doc.querySelector('a.bibtex_copy')).filter(a => a != null).map(a => a.title);
				const bibtex_link = document.getElementById('bibtex_download');
				const bibtex = filtered_docs_bibtex.join('\n\n');
				bibtex_link.title = bibtex;
				//bibtex_link.download = `${tab_name}.bib`;
				//bibtex_link.href = "data:text/plain;base64," + base64_encode_utf8(bibtex);
			}
			
			function reset_selection()
			{
				if(document.querySelectorAll('li.filtered input[type=checkbox]:checked').length > 0)
				{
					document.querySelectorAll('input[type=checkbox]').forEach(checkbox => {checkbox.checked = false;});
					update_docs_counter(false, 0);
				}
				else
				{
					const checkboxes = document.querySelectorAll('li.filtered input[type=checkbox]');
					checkboxes.forEach(checkbox => {checkbox.checked = true;});
					update_docs_counter(false, checkboxes.length);
				}
			}
			
			function navigate()
			{
				const hash = window.location.hash != '' ? decodeURIComponent(window.location.hash.substr('#filter='.length)).split('+').join(' ') : '';
				const routes = {'#' : 'data-tags~', '@' : 'data-authors~', '': 'data-title*'};
				const sorted = Object.keys(routes).sort((lhs, rhs) => rhs.length - lhs.length);
				const selector = hash != '' ? hash.split(' ').map(w => [w, sorted.find(r => w.startsWith(r))]).map(([w, r]) => `[${routes[r]}="${w.substr(r.length).toLowerCase()}"]`).join('') : '';
				
				document.querySelectorAll('.doc').forEach(d => d.classList.remove('filtered'));
				document.querySelectorAll('.doc' + selector).forEach(d => d.classList.add('filtered'));
				document.querySelectorAll('.doc:not(.filtered)').forEach(d => {d.hidden = true;});
				document.querySelectorAll('.doc.filtered').forEach(reset_doc);
				document.getElementById('filter_area').value = hash;
				document.getElementById('filter_area').onkeyup = filter_keyup;
				
				if(selector != '')
				{
					update_tab_bibtex_links('filtered');
					update_docs_counter(true, true);
				}
			}
		</script>
	</body>
</html>
